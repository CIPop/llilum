// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
namespace System
{
    using System;
    using System.Reflection;
    using System.Runtime.Serialization;
    using System.Runtime.CompilerServices;

    [Microsoft.Zelig.Internals.WellKnownType( "System_MulticastDelegate" )]
    [Serializable]
    public abstract class MulticastDelegate : Delegate
    {
////    private Object m_invocationList;
////    private IntPtr m_invocationCount;
////
////    // This constructor is called from the class generated by the
////    //    compiler generated code (This must match the constructor
////    //    in Delegate
////    protected MulticastDelegate( Object target, String method ) : base( target, method )
////    {
////    }
////
////    // This constructor is called from a class to generate a
////    // delegate based upon a static method name and the Type object
////    // for the class defining the method.
////    protected MulticastDelegate( Type target, String method ) : base( target, method )
////    {
////    }
////
////    internal bool IsUnmanagedFunctionPtr()
////    {
////        return (m_invocationCount == (IntPtr)(-1));
////    }
////
////    public override void GetObjectData( SerializationInfo info, StreamingContext context )
////    {
////        int      targetIndex    = 0;
////        Object[] invocationList = m_invocationList as Object[];
////
////        if(invocationList == null)
////        {
////            MethodInfo method = Method;
////
////            // if it is a delegate over a DynamicMethod or an unmanaged function pointer, throw
////            if(method is System.Reflection.Emit.DynamicMethod || method is System.Reflection.Emit.DynamicMethod.RTDynamicMethod || IsUnmanagedFunctionPtr())
////            {
////                throw new SerializationException( Environment.GetResourceString( "Serialization_InvalidDelegateType" ) );
////            }
////
////            // We can't deal with secure delegates either.
////            if(m_invocationList != null && !m_invocationCount.IsNull())
////            {
////                throw new SerializationException( Environment.GetResourceString( "Serialization_InvalidDelegateType" ) );
////            }
////
////            DelegateSerializationHolder.GetDelegateSerializationInfo( info, this.GetType(), Target, method, targetIndex );
////        }
////        else
////        {
////            DelegateSerializationHolder.DelegateEntry nextDe = null;
////
////            int invocationCount = (int)m_invocationCount;
////            for(int i = invocationCount; --i >= 0; )
////            {
////                MulticastDelegate d = (MulticastDelegate)invocationList[i];
////
////                MethodInfo method = d.Method;
////                if(method is System.Reflection.Emit.DynamicMethod || method is System.Reflection.Emit.DynamicMethod.RTDynamicMethod || IsUnmanagedFunctionPtr())
////                {
////                    continue;
////                }
////
////                // We can't deal with secure delegates either.
////                if(d.m_invocationList != null && !d.m_invocationCount.IsNull())
////                {
////                    continue;
////                }
////
////                DelegateSerializationHolder.DelegateEntry de = DelegateSerializationHolder.GetDelegateSerializationInfo( info, d.GetType(), d.Target, method, targetIndex++ );
////                if(nextDe != null)
////                {
////                    nextDe.Entry = de;
////                }
////
////                nextDe = de;
////            }
////
////            // if nothing was serialized it is a delegate over a DynamicMethod, so just throw
////            if(nextDe == null)
////            {
////                throw new SerializationException( Environment.GetResourceString( "Serialization_InvalidDelegateType" ) );
////            }
////        }
////    }
    
        // equals returns true IIF the delegate is not null and has the
        //    same target, method and invocation list as this object
        [MethodImpl( MethodImplOptions.InternalCall )]
        public override extern bool Equals( Object obj );
////    {
////        if(obj == null || !InternalEqualTypes( this, obj ))
////        {
////            return false;
////        }
////
////        MulticastDelegate d = obj as MulticastDelegate;
////        if(d == null)
////        {
////            return false;
////        }
////
////        if(m_invocationCount != (IntPtr)0)
////        {
////            // there are 4 kind of delegate kinds that fall into this bucket
////            // 1- Multicast (_invocationList is Object[])
////            // 2- Secure (_invocationList is Delegate)
////            // 3- Unmanaged FntPtr (_invocationList == null)
////            // 4- Open virtual (_invocationCount == MethodDesc of target)
////
////            if(m_invocationList == null)
////            {
////                if(IsUnmanagedFunctionPtr())
////                {
////                    if(!d.IsUnmanagedFunctionPtr())
////                        return false;
////
////                    if(m_methodPtr != d.m_methodPtr)
////                    {
////                        return false;
////                    }
////
////                    if(GetUnmanagedCallSite() != d.GetUnmanagedCallSite())
////                    {
////                        return false;
////                    }
////
////                    return true;
////                }
////
////                return base.Equals( obj );
////            }
////            else
////            {
////                if((m_invocationList as Delegate) != null)
////                {
////                    // this is a secure delegate so we need to unwrap and check the inner one
////                    return m_invocationList.Equals( obj );
////                }
////                else
////                {
////                    BCLDebug.Assert( (_invocationList as Object[]) != null, "empty invocation list on multicast delegate" );
////
////                    return InvocationListEquals( d );
////                }
////            }
////        }
////        else
////        {
////            // among the several kind of delegates falling into this bucket one has got a non
////            // empty _invocationList (open static with special sig)
////            // to be equals we need to check that _invocationList matches (both null is fine)
////            // and call the base.Equals()
////            if(m_invocationList != null)
////            {
////                if(!m_invocationList.Equals( d.m_invocationList ))
////                {
////                    return false;
////                }
////
////                return base.Equals( d );
////            }
////
////            // now we know 'this' is not a special one, so we can work out what the other is
////            if(d.m_invocationList != null || d.m_invocationCount != (IntPtr)0)
////            {
////                if((d.m_invocationList as Delegate) != null)
////                {
////                    // this is a secure delegate so we need to unwrap and check the inner one
////                    return (d.m_invocationList as Delegate).Equals( this );
////                }
////
////                return false;
////            }
////
////            // now we can call on the base
////            return base.Equals( d );
////        }
////    }
    
        [MethodImpl( MethodImplOptions.InternalCall )]
        public override extern int GetHashCode();
////    {
////        if(IsUnmanagedFunctionPtr())
////        {
////            return unchecked( (int)((long)this.m_methodPtr) );
////        }
////
////        Object[] invocationList = m_invocationList as Object[];
////        if(invocationList == null)
////        {
////            return base.GetHashCode();
////        }
////        else
////        {
////            int hash = 0;
////            for(int i = 0; i < (int)m_invocationCount; i++)
////            {
////                hash = hash * 33 + invocationList[i].GetHashCode();
////            }
////
////            return hash;
////        }
////    }
////
////
////    // Recursive function which will check for equality of the invocation list.
////    private bool InvocationListEquals( MulticastDelegate d )
////    {
////        BCLDebug.Assert( d != null && (m_invocationList as Object[]) != null, "bogus delegate in multicast list comparison" );
////
////        if(d.m_invocationCount != m_invocationCount)
////        {
////            return false;
////        }
////
////        Object[] invocationList  =      m_invocationList as Object[];
////        int      invocationCount = (int)m_invocationCount;
////        for(int i = 0; i < invocationCount; i++)
////        {
////            Delegate dd = (Delegate)invocationList[i];
////
////            Object[] dInvocationList = d.m_invocationList as Object[];
////            if(!dd.Equals( dInvocationList[i] ))
////            {
////                return false;
////            }
////        }
////
////        return true;
////    }
////
////    private bool TrySetSlot( Object[] a, int index, Object o )
////    {
////        if(a[index] == null && System.Threading.Interlocked.CompareExchange( ref a[index], o, null ) == null)
////        {
////            return true;
////        }
////
////        // The slot may be already set because we have added and removed the same method before.
////        // Optimize this case, because it's cheaper than copying the array.
////        if(a[index] != null)
////        {
////            MulticastDelegate d  = (MulticastDelegate)o;
////            MulticastDelegate dd = (MulticastDelegate)a[index];
////
////            if(dd.m_methodPtr     == d.m_methodPtr    &&
////                dd.m_target       == d.m_target       &&
////                dd.m_methodPtrAux == d.m_methodPtrAux  )
////            {
////                return true;
////            }
////        }
////
////        return false;
////    }
////
////    internal MulticastDelegate NewMulticastDelegate( Object[] invocationList, int invocationCount, bool thisIsMultiCastAlready )
////    {
////        // First, allocate a new multicast delegate just like this one, i.e. same type as the this object
////        MulticastDelegate result = (MulticastDelegate)InternalAllocLike( this );
////
////        // Performance optimization - if this already points to a true multicast delegate,
////        // copy _methodPtr and _methodPtrAux fields rather than calling into the EE to get them
////        if(thisIsMultiCastAlready)
////        {
////            result.m_methodPtr    = this.m_methodPtr;
////            result.m_methodPtrAux = this.m_methodPtrAux;
////        }
////        else
////        {
////            result.m_methodPtr    = GetMulticastInvoke();
////            result.m_methodPtrAux = GetInvokeMethod();
////        }
////
////        result.m_target          =         result;
////        result.m_invocationList  =         invocationList;
////        result.m_invocationCount = (IntPtr)invocationCount;
////
////        return result;
////    }
////
////    internal MulticastDelegate NewMulticastDelegate( Object[] invocationList, int invocationCount )
////    {
////        return NewMulticastDelegate( invocationList, invocationCount, false );
////    }
////
////    internal void StoreDynamicMethod( MethodInfo dynamicMethod )
////    {
////        if(m_invocationCount != (IntPtr)0)
////        {
////            BCLDebug.Assert( !IsUnmanagedFunctionPtr(), "dynamic method and unmanaged fntptr delegate combined" );
////            // must be a secure one, unwrap and save
////            MulticastDelegate d = (MulticastDelegate)m_invocationList;
////            d.m_methodBase = dynamicMethod;
////
////        }
////        else
////        {
////            m_methodBase = dynamicMethod;
////        }
////    }
////
////    // This method will combine this delegate with the passed delegate to form a new delegate.
////    protected override sealed Delegate CombineImpl( Delegate follow )
////    {
////        // Verify that the types are the same...
////        // Actually, we don't need to do this, because Delegate.Combine already checks this.
////        //            if (!InternalEqualTypes(this, follow)
////        //                throw new ArgumentException(Environment.GetResourceString("Arg_DlgtTypeMis"));
////
////        MulticastDelegate dFollow = (MulticastDelegate)follow;
////
////        Object[] resultList;
////        int      followCount = 1;
////        Object[] followList  = dFollow.m_invocationList as Object[];
////        if(followList != null)
////        {
////            followCount = (int)dFollow.m_invocationCount;
////        }
////
////        int      resultCount;
////        Object[] invocationList = m_invocationList as Object[];
////        if(invocationList == null)
////        {
////            resultCount = 1 + followCount;
////            resultList  = new Object[resultCount];
////
////            resultList[0] = this;
////            if(followList == null)
////            {
////                resultList[1] = dFollow;
////            }
////            else
////            {
////                for(int i = 0; i < followCount; i++)
////                {
////                    resultList[1 + i] = followList[i];
////                }
////            }
////
////            return NewMulticastDelegate( resultList, resultCount );
////        }
////        else
////        {
////            int invocationCount = (int)m_invocationCount;
////
////            resultCount = invocationCount + followCount;
////            resultList  = null;
////
////            if(resultCount <= invocationList.Length)
////            {
////                resultList = invocationList;
////                if(followList == null)
////                {
////                    if(!TrySetSlot( resultList, invocationCount, dFollow ))
////                    {
////                        resultList = null;
////                    }
////                }
////                else
////                {
////                    for(int i = 0; i < followCount; i++)
////                    {
////                        if(!TrySetSlot( resultList, invocationCount + i, followList[i] ))
////                        {
////                            resultList = null;
////                            break;
////                        }
////                    }
////                }
////            }
////
////            if(resultList == null)
////            {
////                int allocCount = invocationList.Length;
////                while(allocCount < resultCount)
////                {
////                    allocCount *= 2;
////                }
////
////                resultList = new Object[allocCount];
////
////                for(int i = 0; i < invocationCount; i++)
////                {
////                    resultList[i] = invocationList[i];
////                }
////
////                if(followList == null)
////                {
////                    resultList[invocationCount] = dFollow;
////                }
////                else
////                {
////                    for(int i = 0; i < followCount; i++)
////                    {
////                        resultList[invocationCount + i] = followList[i];
////                    }
////                }
////            }
////            return NewMulticastDelegate( resultList, resultCount, true );
////        }
////    }
////
////    private Object[] DeleteFromInvocationList( Object[] invocationList, int invocationCount, int deleteIndex, int deleteCount )
////    {
////        Object[] thisInvocationList = m_invocationList as Object[];
////
////        int allocCount = thisInvocationList.Length;
////        while(allocCount / 2 >= invocationCount - deleteCount)
////        {
////            allocCount /= 2;
////        }
////
////        Object[] newInvocationList = new Object[allocCount];
////
////        for(int i = 0; i < deleteIndex; i++)
////        {
////            newInvocationList[i] = invocationList[i];
////        }
////
////        for(int i = deleteIndex + deleteCount; i < invocationCount; i++)
////        {
////            newInvocationList[i - deleteCount] = invocationList[i];
////        }
////
////        return newInvocationList;
////    }
////
////    private bool EqualInvocationLists( Object[] a, Object[] b, int start, int count )
////    {
////        for(int i = 0; i < count; i++)
////        {
////            if(!(a[start + i].Equals( b[i] )))
////            {
////                return false;
////            }
////        }
////
////        return true;
////    }
////
////    // This method currently looks backward on the invocation list
////    //    for an element that has Delegate based equality with value.  (Doesn't
////    //    look at the invocation list.)  If this is found we remove it from
////    //    this list and return a new delegate.  If its not found a copy of the
////    //    current list is returned.
////    protected override sealed Delegate RemoveImpl( Delegate value )
////    {
////        // There is a special case were we are removing using a delegate as
////        //    the value we need to check for this case
////        //
////        MulticastDelegate v = value as MulticastDelegate;
////
////        if(v == null)
////        {
////            return this;
////        }
////
////        if(v.m_invocationList as Object[] == null)
////        {
////            Object[] invocationList = m_invocationList as Object[];
////            if(invocationList == null)
////            {
////                // they are both not real Multicast
////                if(this.Equals( value ))
////                    return null;
////            }
////            else
////            {
////                int invocationCount = (int)m_invocationCount;
////                for(int i = invocationCount; --i >= 0; )
////                {
////                    if(value.Equals( invocationList[i] ))
////                    {
////                        if(invocationCount == 2)
////                        {
////                            // Special case - only one value left, either at the beginning or the end
////                            return (Delegate)invocationList[1 - i];
////                        }
////                        else
////                        {
////                            Object[] list = DeleteFromInvocationList( invocationList, invocationCount, i, 1 );
////
////                            return NewMulticastDelegate( list, invocationCount - 1, true );
////                        }
////                    }
////                }
////            }
////        }
////        else
////        {
////            Object[] invocationList = m_invocationList as Object[];
////
////            if(invocationList != null)
////            {
////                int invocationCount  = (int)  m_invocationCount;
////                int vInvocationCount = (int)v.m_invocationCount;
////                for(int i = invocationCount - vInvocationCount; i >= 0; i--)
////                {
////                    if(EqualInvocationLists( invocationList, v.m_invocationList as Object[], i, vInvocationCount ))
////                    {
////                        if(invocationCount - vInvocationCount == 0)
////                        {
////                            // Special case - no values left
////                            return null;
////                        }
////                        else if(invocationCount - vInvocationCount == 1)
////                        {
////                            // Special case - only one value left, either at the beginning or the end
////                            return (Delegate)invocationList[i != 0 ? 0 : invocationCount - 1];
////                        }
////                        else
////                        {
////                            Object[] list = DeleteFromInvocationList( invocationList, invocationCount, i, vInvocationCount );
////
////                            return NewMulticastDelegate( list, invocationCount - vInvocationCount, true );
////                        }
////                    }
////                }
////            }
////        }
////
////        return this;
////    }
////
////    // This method returns the Invocation list of this multicast delegate.
////    public override sealed Delegate[] GetInvocationList()
////    {
////        Delegate[] del;
////        Object[]   invocationList = m_invocationList as Object[];
////        if(invocationList == null)
////        {
////            del    = new Delegate[1];
////            del[0] = this;
////        }
////        else
////        {
////            // Create an array of delegate copies and each
////            //    element into the array
////            int invocationCount = (int)m_invocationCount;
////
////            del = new Delegate[invocationCount];
////
////            for(int i = 0; i < invocationCount; i++)
////            {
////                del[i] = (Delegate)invocationList[i];
////            }
////        }
////
////        return del;
////    }

        public static bool operator ==( MulticastDelegate d1, MulticastDelegate d2 )
        {
            if((Object)d1 == null)
            {
                return (Object)d2 == null;
            }

            return d1.Equals( d2 );
        }

        public static bool operator !=( MulticastDelegate d1, MulticastDelegate d2 )
        {
            if((Object)d1 == null)
            {
                return (Object)d2 != null;
            }

            return !d1.Equals( d2 );
        }

////    internal override Object GetTarget()
////    {
////        if(m_invocationCount != (IntPtr)0)
////        {
////            // _invocationCount != 0 we are in one of these cases:
////            // - Multicast -> return the target of the last delegate in the list
////            // - Secure delegate -> return the target of the inner delegate
////            // - unmanaged function pointer - return null
////            // - virtual open delegate - return base.GetTarget()
////            if(m_invocationList == null)
////            {
////                // both open virtual and ftn pointer return null for the target
////                return null;
////            }
////            else
////            {
////                Object[] invocationList = m_invocationList as Object[];
////                if(invocationList != null)
////                {
////                    int invocationCount = (int)m_invocationCount;
////                    return ((Delegate)invocationList[invocationCount - 1]).GetTarget();
////                }
////                else
////                {
////                    Delegate receiver = m_invocationList as Delegate;
////                    if(receiver != null)
////                        return receiver.GetTarget();
////                }
////            }
////        }
////        return base.GetTarget();
////    }
////
////    protected override MethodInfo GetMethodImpl()
////    {
////        if(m_invocationCount != (IntPtr)0 && m_invocationList != null)
////        {
////            // multicast case
////            Object[] invocationList = m_invocationList as Object[];
////            if(invocationList != null)
////            {
////                int index = (int)m_invocationCount - 1;
////                return ((Delegate)invocationList[index]).Method;
////            }
////            else
////            {
////                // must be a secure delegate
////                return ((MulticastDelegate)m_invocationList).GetMethodImpl();
////            }
////        }
////
////        return base.GetMethodImpl();
////    }
////
////    // this should help inlining
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void ThrowNullThisInDelegateToInstance()
////    {
////        throw new ArgumentException( Environment.GetResourceString( "Arg_DlgtNullInst" ) );
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorClosed( Object target, IntPtr methodPtr )
////    {
////        if(target == null)
////        {
////            ThrowNullThisInDelegateToInstance();
////        }
////
////        this.m_target    = target;
////        this.m_methodPtr = methodPtr;
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorClosedStatic( Object target, IntPtr methodPtr )
////    {
////        this.m_target    = target;
////        this.m_methodPtr = methodPtr;
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorRTClosed( Object target, IntPtr methodPtr )
////    {
////        this.m_target    = target;
////        this.m_methodPtr = AdjustTarget( target, methodPtr );
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorOpened( Object target, IntPtr methodPtr, IntPtr shuffleThunk )
////    {
////        this.m_target       = this;
////        this.m_methodPtr    = shuffleThunk;
////        this.m_methodPtrAux = methodPtr;
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorSecureClosed( Object target, IntPtr methodPtr, IntPtr callThunk, IntPtr assembly )
////    {
////        MulticastDelegate realDelegate = (MulticastDelegate)Delegate.InternalAlloc( Type.GetTypeHandle( this ) );
////
////        realDelegate.CtorClosed( target, methodPtr );
////
////        this.m_invocationList  = realDelegate;
////        this.m_target          = this;
////        this.m_methodPtr       = callThunk;
////        this.m_methodPtrAux    = assembly;
////        this.m_invocationCount = GetInvokeMethod();
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorSecureClosedStatic( Object target, IntPtr methodPtr, IntPtr callThunk, IntPtr assembly )
////    {
////        MulticastDelegate realDelegate = (MulticastDelegate)Delegate.InternalAlloc( Type.GetTypeHandle( this ) );
////
////        realDelegate.CtorClosedStatic( target, methodPtr );
////
////        this.m_invocationList  = realDelegate;
////        this.m_target          = this;
////        this.m_methodPtr       = callThunk;
////        this.m_methodPtrAux    = assembly;
////        this.m_invocationCount = GetInvokeMethod();
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorSecureRTClosed( Object target, IntPtr methodPtr, IntPtr callThunk, IntPtr assembly )
////    {
////        MulticastDelegate realDelegate = Delegate.InternalAlloc( Type.GetTypeHandle( this ) );
////
////        realDelegate.CtorRTClosed( target, methodPtr );
////
////        this.m_invocationList  = realDelegate;
////        this.m_target          = this;
////        this.m_methodPtr       = callThunk;
////        this.m_methodPtrAux    = assembly;
////        this.m_invocationCount = GetInvokeMethod();
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorSecureOpened( Object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr callThunk, IntPtr assembly )
////    {
////        MulticastDelegate realDelegate = Delegate.InternalAlloc( Type.GetTypeHandle( this ) );
////
////        realDelegate.CtorOpened( target, methodPtr, shuffleThunk );
////
////        this.m_invocationList  = realDelegate;
////        this.m_target          = this;
////        this.m_methodPtr       = callThunk;
////        this.m_methodPtrAux    = assembly;
////        this.m_invocationCount = GetInvokeMethod();
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorVirtualDispatch( Object target, IntPtr methodPtr, IntPtr shuffleThunk )
////    {
////        this.m_target       = this;
////        this.m_methodPtr    = shuffleThunk;
////        this.m_methodPtrAux = GetCallStub( methodPtr );
////    }
////
////    [System.Diagnostics.DebuggerNonUserCode]
////    private void CtorSecureVirtualDispatch( Object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr callThunk, IntPtr assembly )
////    {
////        MulticastDelegate realDelegate = Delegate.InternalAlloc( Type.GetTypeHandle( this ) );
////
////        realDelegate.CtorVirtualDispatch( target, methodPtr, shuffleThunk );
////
////        this.m_invocationList  = realDelegate;
////        this.m_target          = this;
////        this.m_methodPtr       = callThunk;
////        this.m_methodPtrAux    = assembly;
////        this.m_invocationCount = GetInvokeMethod();
////    }
    }
}
